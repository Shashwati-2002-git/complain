import { User } from '../models/User.js';
import { Complaint } from '../models/Complaint.js';
import { Notification } from '../models/Notification.js';

// Store connected users by userId for targeted messaging
const connectedUsers = new Map();

// Track connection attempts to prevent connection floods
const connectionAttempts = new Map();

export const handleConnection = (io) => {
  io.on('connection', async (socket) => {
    const clientIp = socket.handshake.address || 'unknown';
    const timestamp = Date.now();
    
    // Rate limit connection attempts
    if (connectionAttempts.has(clientIp)) {
      const attempts = connectionAttempts.get(clientIp);
      const recentAttempts = attempts.filter(time => timestamp - time < 10000); // Within 10 seconds
      
      if (recentAttempts.length >= 5) {
        console.log(`Too many connection attempts from ${clientIp}. Blocking connection.`);
        socket.disconnect();
        return;
      }
      
      connectionAttempts.set(clientIp, [...recentAttempts, timestamp]);
    } else {
      connectionAttempts.set(clientIp, [timestamp]);
    }
    
    console.log(`Client connected: ${socket.id} from ${clientIp}`);

    // User should be available from authentication middleware
    if (!socket.user) {
      console.error('Socket missing user data after middleware - this should never happen');
      socket.disconnect();
      return;
    }
    
    const user = socket.user;
    console.log(`User authenticated: ${user.name || `${user.firstName} ${user.lastName}`} (${user.role})`);
    
    // Store user connection for targeted messaging
    const userId = user._id.toString();
    
    // Check if this user already has an active connection
    const existingConnection = connectedUsers.get(userId);
    if (existingConnection) {
      console.log(`User ${userId} already has active connection ${existingConnection.socketId}, handling duplicate...`);
      
      // Option 1: Force disconnect the old connection
      const oldSocket = io.sockets.sockets.get(existingConnection.socketId);
      if (oldSocket) {
        console.log(`Disconnecting previous socket ${existingConnection.socketId} for user ${userId}`);
        oldSocket.emit('error', { message: 'New login detected from another device' });
        oldSocket.disconnect();
      }
    }
    
    // Store the new connection
    connectedUsers.set(userId, {
      socketId: socket.id,
      userId,
      userName: user.name || `${user.firstName} ${user.lastName}`,
      role: user.role
    });
    
    console.log(`Total connected users: ${connectedUsers.size}`);
    
    // Send user their unread notifications
    try {
      const unreadNotifications = await Notification.find({
        recipient: userId,
        isRead: false
      }).sort({ createdAt: -1 });
      
      socket.emit('connected', { 
        user: { 
          id: userId, 
          name: user.name || `${user.firstName} ${user.lastName}`,
          role: user.role 
        },
        unreadNotifications
      });
    } catch (error) {
      console.error('Error retrieving notifications:', error);
    }
    
    // Broadcast online users to all clients
    broadcastOnlineUsers(io);
    
    // Handle user disconnect
    socket.on('disconnect', () => {
      console.log(`Client disconnected: ${socket.id}`);
      
      // Remove from connected users map
      for (const [id, conn] of connectedUsers.entries()) {
        if (conn.socketId === socket.id) {
          connectedUsers.delete(id);
          console.log(`User ${id} removed from connected users map`);
          broadcastOnlineUsers(io);
          break;
        }
      }
    });
    
    // Join complaint room
    socket.on('join_complaint', async (data) => {
      try {
        const { complaintId } = data;
        if (!complaintId) return;
        
        console.log(`User ${userId} joining complaint room ${complaintId}`);
        socket.join(`complaint:${complaintId}`);
        
        // Notify others that user is viewing the complaint
        socket.to(`complaint:${complaintId}`).emit('user_joined', {
          userId,
          userName: user.name || `${user.firstName} ${user.lastName}`
        });
      } catch (error) {
        console.error('Error joining complaint room:', error);
      }
    });
    
    // Leave complaint room
    socket.on('leave_complaint', async (data) => {
      try {
        const { complaintId } = data;
        if (!complaintId) return;
        
        console.log(`User ${userId} leaving complaint room ${complaintId}`);
        socket.leave(`complaint:${complaintId}`);
        
        // Notify others that user left
        socket.to(`complaint:${complaintId}`).emit('user_left', {
          userId,
          userName: user.name || `${user.firstName} ${user.lastName}`
        });
      } catch (error) {
        console.error('Error leaving complaint room:', error);
      }
    });
    
    // User typing indicator
    socket.on('typing', (data) => {
      try {
        const { complaintId } = data;
        if (!complaintId) return;
        
        socket.to(`complaint:${complaintId}`).emit('user_typing', {
          userId,
          userName: user.name || `${user.firstName} ${user.lastName}`
        });
      } catch (error) {
        console.error('Error with typing indicator:', error);
      }
    });
    
    // User stopped typing
    socket.on('stop_typing', (data) => {
      try {
        const { complaintId } = data;
        if (!complaintId) return;
        
        socket.to(`complaint:${complaintId}`).emit('user_stopped_typing', {
          userId
        });
      } catch (error) {
        console.error('Error with stop typing indicator:', error);
      }
    });
    
    // Send message
    socket.on('send_message', async (data) => {
      try {
        const { complaintId, message } = data;
        if (!complaintId || !message) return;
        
        const complaint = await Complaint.findById(complaintId);
        if (!complaint) {
          socket.emit('error', { message: 'Complaint not found' });
          return;
        }
        
        // Add message to complaint
        const newMessage = {
          sender: userId,
          senderName: user.name || `${user.firstName} ${user.lastName}`,
          senderRole: user.role,
          text: message,
          timestamp: new Date()
        };
        
        complaint.messages.push(newMessage);
        await complaint.save();
        
        // Broadcast to all in room
        io.to(`complaint:${complaintId}`).emit('new_message', {
          message: newMessage,
          complaintId
        });
        
        // Create notification for recipients
        if (user.role === 'user') {
          // If sent by regular user, notify assigned agents and admins
          const targetUsers = complaint.assignedTo ? [complaint.assignedTo] : [];
          
          // Always notify admins of new customer messages
          const admins = await User.find({ role: 'admin' }).select('_id');
          admins.forEach(admin => {
            if (admin._id.toString() !== userId) {
              targetUsers.push(admin._id);
            }
          });
          
          await createNotifications(targetUsers, {
            title: 'New Message',
            message: `New message in complaint #${complaint.ticketNumber}`,
            type: 'message',
            relatedId: complaintId,
            sender: userId
          });
        } else {
          // If sent by staff, notify the customer
          await createNotifications([complaint.user], {
            title: 'New Response',
            message: `Staff response to your complaint #${complaint.ticketNumber}`,
            type: 'message',
            relatedId: complaintId,
            sender: userId
          });
        }
      } catch (error) {
        console.error('Error sending message:', error);
        socket.emit('error', { message: 'Failed to send message' });
      }
    });
    
    // Send internal note
    socket.on('internal_message', async (data) => {
      try {
        const { complaintId, message } = data;
        if (!complaintId || !message) return;
        
        // Only allow staff to send internal messages
        if (user.role === 'user') {
          socket.emit('error', { message: 'Not authorized to send internal messages' });
          return;
        }
        
        const complaint = await Complaint.findById(complaintId);
        if (!complaint) {
          socket.emit('error', { message: 'Complaint not found' });
          return;
        }
        
        // Add internal note
        const newNote = {
          sender: userId,
          senderName: user.name || `${user.firstName} ${user.lastName}`,
          senderRole: user.role,
          text: message,
          timestamp: new Date(),
          isInternal: true
        };
        
        complaint.internalNotes.push(newNote);
        await complaint.save();
        
        // Only broadcast to staff
        const staffSocketIds = [];
        for (const [id, conn] of connectedUsers.entries()) {
          if (conn.role === 'admin' || conn.role === 'agent' || conn.role === 'analytics') {
            const staffSocket = io.sockets.sockets.get(conn.socketId);
            if (staffSocket) {
              staffSocket.emit('internal_message', {
                note: newNote,
                complaintId
              });
            }
          }
        }
        
        // Create notifications for other staff
        const staffUsers = await User.find({
          role: { $in: ['admin', 'agent'] },
          _id: { $ne: userId }
        }).select('_id');
        
        await createNotifications(staffUsers.map(u => u._id), {
          title: 'New Internal Note',
          message: `Internal note added to complaint #${complaint.ticketNumber}`,
          type: 'internal_note',
          relatedId: complaintId,
          sender: userId
        });
      } catch (error) {
        console.error('Error sending internal message:', error);
        socket.emit('error', { message: 'Failed to send internal message' });
      }
    });
    
    // Mark notifications as read
    socket.on('mark_notifications_read', async (data) => {
      try {
        const { notificationIds } = data;
        if (!notificationIds || !Array.isArray(notificationIds)) return;
        
        await Notification.updateMany(
          { 
            _id: { $in: notificationIds },
            recipient: userId
          },
          { $set: { isRead: true } }
        );
        
        socket.emit('notifications_marked_read', { notificationIds });
      } catch (error) {
        console.error('Error marking notifications as read:', error);
      }
    });
    
    // Update complaint
    socket.on('update_complaint', async (data) => {
      try {
        const { complaintId, updates, note } = data;
        if (!complaintId || !updates) return;
        
        // Only staff can update complaints
        if (user.role === 'user') {
          socket.emit('error', { message: 'Not authorized to update complaints' });
          return;
        }
        
        const complaint = await Complaint.findById(complaintId);
        if (!complaint) {
          socket.emit('error', { message: 'Complaint not found' });
          return;
        }
        
        // Apply updates
        Object.keys(updates).forEach(key => {
          if (key in complaint) {
            complaint[key] = updates[key];
          }
        });
        
        // If status changed, record it in history
        if (updates.status && updates.status !== complaint.status) {
          complaint.statusHistory.push({
            status: updates.status,
            changedBy: userId,
            timestamp: new Date(),
            note: note || `Status updated to ${updates.status}`
          });
        }
        
        // If adding a note about the change
        if (note) {
          complaint.internalNotes.push({
            sender: userId,
            senderName: user.name || `${user.firstName} ${user.lastName}`,
            senderRole: user.role,
            text: note,
            timestamp: new Date(),
            isInternal: true,
            isSystemNote: true
          });
        }
        
        await complaint.save();
        
        // Broadcast update to room
        io.to(`complaint:${complaintId}`).emit('complaint_updated', {
          complaint,
          updatedBy: {
            id: userId,
            name: user.name || `${user.firstName} ${user.lastName}`,
            role: user.role
          },
          updates
        });
        
        // Create notification for customer if status changed
        if (updates.status) {
          await createNotifications([complaint.user], {
            title: 'Complaint Updated',
            message: `Your complaint #${complaint.ticketNumber} status changed to ${updates.status}`,
            type: 'status_change',
            relatedId: complaintId,
            sender: userId
          });
        }
        
        // Dashboard update for staff
        broadcastDashboardUpdate(io);
      } catch (error) {
        console.error('Error updating complaint:', error);
        socket.emit('error', { message: 'Failed to update complaint' });
      }
    });
  });
};

// Helper to create notifications
async function createNotifications(recipients, notificationData) {
  try {
    const notifications = [];
    
    for (const recipientId of recipients) {
      if (recipientId) {
        const notification = await Notification.create({
          recipient: recipientId,
          ...notificationData,
          isRead: false,
          createdAt: new Date()
        });
        
        notifications.push(notification);
        
        // Emit to recipient if online
        const recipientConnection = connectedUsers.get(recipientId.toString());
        if (recipientConnection) {
          const socket = io.sockets.sockets.get(recipientConnection.socketId);
          if (socket) {
            socket.emit('notification', { notification });
          }
        }
      }
    }
    
    return notifications;
  } catch (error) {
    console.error('Error creating notifications:', error);
    return [];
  }
}

// Helper to broadcast online users
function broadcastOnlineUsers(io) {
  const onlineUsers = Array.from(connectedUsers.values()).map(user => ({
    userId: user.userId,
    userName: user.userName,
    role: user.role
  }));
  
  io.emit('online_users', onlineUsers);
}

// Helper to broadcast dashboard updates
async function broadcastDashboardUpdate(io) {
  try {
    // Get aggregated stats
    const totalComplaints = await Complaint.countDocuments();
    const openComplaints = await Complaint.countDocuments({ status: { $nin: ['closed', 'resolved'] } });
    const resolvedComplaints = await Complaint.countDocuments({ status: 'resolved' });
    
    // Recent activity
    const recentActivity = await Complaint.find()
      .sort({ updatedAt: -1 })
      .limit(5)
      .select('ticketNumber title status updatedAt');
    
    const dashboardData = {
      stats: {
        total: totalComplaints,
        open: openComplaints,
        resolved: resolvedComplaints,
        closed: totalComplaints - openComplaints - resolvedComplaints
      },
      recentActivity
    };
    
    // Broadcast to admin and agent roles
    for (const [userId, conn] of connectedUsers.entries()) {
      if (conn.role === 'admin' || conn.role === 'agent' || conn.role === 'analytics') {
        const socket = io.sockets.sockets.get(conn.socketId);
        if (socket) {
          socket.emit('dashboard_update', dashboardData);
        }
      }
    }
  } catch (error) {
    console.error('Error broadcasting dashboard update:', error);
  }
}